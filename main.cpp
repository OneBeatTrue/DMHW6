#include <iostream>
#include <vector>
#include <map>

std::map<char, char> con{
    {'A', 'U'},
    {'U', 'A'},
    {'G', 'C'},
    {'C', 'G'}
}; // какой элемент какому соответствует

std::vector<std::map<char, int>> d(21,
   {
            {'A', 0},
            {'U', 0},
            {'G', 0},
            {'C', 0}
        }
); // вектор префиксных сумм по количеству элементов для каждого вида (чтобы узнавать сколько элементов каждого вида в данной половине за О(1) времени)

std::vector<char> g{'C', 'G', 'U', 'A', 'A', 'U', 'U', 'A', 'C', 'G', 'G', 'C', 'A', 'U', 'U', 'A', 'G', 'C', 'A', 'U'}; // элементы в порядке расположения на круге

bool condition(int a, int b) { // передаем рассматриваемую часть (левая граница включительно, правая тоже включительно)
    std::map<char, int> tmp{
        {'A', 0},
        {'U', 0},
        {'G', 0},
        {'C', 0}
    };
    for (auto& i : tmp) {
        i.second = d[b + 1][i.first] - d[a][i.first]; // с помощью массива префиксных сумм вычисляем количество элементов каждого вида в данной части
    }
    return tmp['A'] == tmp['U'] && tmp['G'] == tmp['C'];
}

int partition(int l, int r) { // передаем рассматриваемую часть (левая граница включительно, правая исключительно)
    int ans = 0;
    if (l == r) { // в пустой части всего 1 возможный perfect matching
        return 1;
    }
    for (int v = l + 1; v < r; v += 2) { // перебираем все ребра l, v (рассматриваемую часть на две) и проверяем удовлетворяют ли эти части следующим условиям:
        // - количество вершин в частях четно (обеспечивается шагом 2)
        // - вершины l и v соединяют A c U или G с C
        // - количество вершин вида A равно количеству вершин вида U, и количество вершин вида C равно количеству вершин вида G в каждой из частей
        if (g[l] == con[g[v]] && condition(l + 1, v - 1) && condition(l + 1, v - 1)) {
            ans += partition(l + 1, v) * partition(v + 1, r); // perfect matching'и каждой части независимы, поэтому перемножаем результаты
        }
    }
    return ans;
}

int main() {
    for (int i = 1; i < 21; ++i) { // заполняем префиксный массив d
        d[i] = d[i - 1];
        ++d[i][g[i - 1]];
    }
    std::cout << partition(0, 20) << std::endl;
    return 0;
}
